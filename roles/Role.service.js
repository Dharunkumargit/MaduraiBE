import RoleModel from "../roles/Role.schema.js";
import logger from "../config/logger.js";
import Employee from "../models/Employee_Schema.js"; // ✅ Changed from User to Employee
import IdcodeServices from "../idcode/idcode.service.js";

class RoleService {
static async addRole(roleData) {
    try {
      // ✅ Check if role name already exists
      const exists = await RoleModel.findOne({ role_name: roleData.role_name });
      if (exists) {
        throw new Error(`Role "${roleData.role_name}" already exists`);
      }

      // ✅ Generate role_id using YOUR IdcodeService (same as employee)
      const role_id = await IdcodeServices.generateCode("ROLE");
      if (!role_id) {
        throw new Error("Failed to generate role ID");
      }

      // ✅ Set the generated role_id
      roleData.role_id = role_id;
      roleData.created_by_user = roleData.created_by_user || "Administrator";
      roleData.status = roleData.status || "ACTIVE";

      const role = await RoleModel.create(roleData);
      logger.info(`Role created: ${role.role_id}`);
      return role;
    } catch (error) {
      logger.error(`Error while adding role: ${error.message}`);
      throw error;
    }
  }

  static async getRolesById(roleId) {
    try {
      const role = await RoleModel.findOne({ role_id: roleId });
      if (!role) throw new Error("Role not found");
      return role;
    } catch (error) {
      logger.error(`Error while getting role: ${error.message}`);
      throw error;
    }
  }

  static async getAllRoles(page = 1, limit = 8) {
  try {
    const skip = (page - 1) * limit;

    const totalItems = await RoleModel.countDocuments();

    const roles = await RoleModel.find()
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit);

    return {
      data: roles,
      pagination: {
        totalItems,
        currentPage: page,
        totalPages: Math.ceil(totalItems / limit),
      },
    };
  } catch (error) {
    logger.error(`Error while getting all roles: ${error.message}`);
    throw error;
  }
}

  static async updateRole(role_id, updateData) {
    try {
      const role = await RoleModel.findOne({ role_id: role_id });
      if (!role) {
        throw new Error(`Role with ID ${role_id} not found`);
      }

      // ✅ FIXED: Store result and RETURN it
      const updatedRole = await RoleModel.findOneAndUpdate(
        { role_id: role_id },
        { $set: updateData },
        { new: true, runValidators: true }
      );

      logger.info(`Role updated: ${role_id}`);
      return updatedRole; // ✅ MISSING RETURN STATEMENT
    } catch (error) {
      logger.error(`Error while updating role: ${error.message}`);
      throw error;
    }
  }

  static async deleteRoleByMongoId(id) {
    try {
      const deleted = await RoleModel.findByIdAndDelete(id);
      if (!deleted) {
        throw new Error("Role not found");
      }

      // ✅ Update Employee references (matches your schema)
      await Employee.updateMany(
        { role_id: deleted.role_id }, // ✅ Use role_id to match your employee schema
        { $set: { role_id: "", role_name: "" } }
      );

      logger.info(`Role deleted: ${deleted.role_id}`);
      return deleted;
    } catch (error) {
      logger.error(`Error while deleting role: ${error.message}`);
      throw error;
    }
  }

  // ✅ BONUS: Assign role to employee
  static async assignRoleToEmployee(empId, roleId) {
    try {
      const role = await this.getRolesById(roleId);
      const employee = await Employee.findOne({ emp_id: empId });
      
      if (!employee) throw new Error("Employee not found");
      
      // Auto-generate password if first time role assignment
      let updateData = { 
        role_id: role.role_id, 
        role_name: role.role_name 
      };
      
      if (!employee.role_name) {
        const bcrypt = require('bcryptjs');
        const autoPassword = `Emp${employee.emp_id}@${Math.random().toString(36).substr(2, 5)}`;
        updateData.password = await bcrypt.hash(autoPassword, 10);
        employee.autoGeneratedPassword = autoPassword;
      }
      
      return await Employee.findOneAndUpdate(
        { emp_id: empId },
        { $set: updateData },
        { new: true }
      );
    } catch (error) {
      logger.error(`Error assigning role to employee: ${error.message}`);
      throw error;
    }
  }
}

export default RoleService;
