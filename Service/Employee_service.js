import Employee from "../models/Employee_Schema.js";
import IdcodeServices from "../idcode/idcode.service.js";
import bcrypt from "bcryptjs";
import RoleModel from "../roles/Role.schema.js";
import binfulleventSchema from "../bindailydata/binfullevent.schema.js";

// In-memory session store
const activeSessions = new Map();

export const createEmployee = async (data) => {
  const exists = await Employee.findOne({ phonenumber: data.phonenumber });
  if (exists) throw new Error("Phone number already exists!");

  const emp_id = await IdcodeServices.generateCode("EMPLOYEE");
  if (!emp_id) {
    throw new Error("Failed to generate employee ID");
  }

  data.emp_id = emp_id;
  return await Employee.create(data);
};

export const login = async (emailid, password) => {
  const employee = await Employee.findOne({ emailid }).select("+password");

  if (!employee) {
    console.log("âŒ No employee with this email");
    throw new Error("Invalid email");
  }

  const isMatch = await bcrypt.compare(password, employee.password);
  if (!isMatch) {
    console.log("âŒ Passwords don't match");
    throw new Error("Invalid password");
  }

  if (!employee.role_name || employee.role_name === "") {
    throw new Error("Role not assigned. Contact admin.");
  }

  // âœ… PERFECT: Find role by role_id (custom string code)
  const role = await RoleModel.findOne({ role_id: employee.role_id });
  
  console.log("ðŸŽ¯ Role found:", role ? role.role_name : "NOT FOUND");

  // âœ… Generate session with COMPLETE role data
  const sessionId = `sess_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  activeSessions.set(sessionId, {
    id: employee._id,
    emp_id: employee.emp_id,
    role_name: employee.role_name,
    role_id: employee.role_id,
    roleData: role,  // âœ… COMPLETE role document
    name: employee.name,
  });

  return {
    success: true,
    sessionId,
    employee: {
      id: employee._id,
      emp_id: employee.emp_id,
      name: employee.name,
      emailid: employee.emailid,
      phonenumber: employee.phonenumber,
      zone: employee.zone,
      ward: employee.ward,
      location: employee.location,
      role: {
        role_id: employee.role_id,
        role_name: employee.role_name,
        // âœ… YOUR EXACT STRUCTURE - Full accessLevels array
        accessLevels: role?.accessLevels || [],
        status: role?.status || "INACTIVE"
      }
    },
    message: "Login successful",
  };
};



export const logout = async (sessionId) => {
  activeSessions.delete(sessionId);
  return { success: true, message: "Logged out successfully" };
};

export const verifySession = async (sessionId) => {
  if (!activeSessions.has(sessionId)) {
    throw new Error("Invalid or expired session");
  }
  return activeSessions.get(sessionId);
};

export const updateEmployee = async (id, data) => {
  // Verify session first

  const employee = await Employee.findById(id);
  if (!employee) throw new Error("Employee not found");

  // Phone/email uniqueness check
  if (data.phonenumber && data.phonenumber !== employee.phonenumber) {
    const phoneExists = await Employee.findOne({
      phonenumber: data.phonenumber,
      _id: { $ne: id },
    });
    if (phoneExists) throw new Error("Phone number already exists!");
  }

  if (data.emailid && data.emailid !== employee.emailid) {
    const emailExists = await Employee.findOne({
      emailid: data.emailid,
      _id: { $ne: id },
    });
    if (emailExists) throw new Error("Email already exists!");
  }

  if (data.role_name && !employee.role_name) {
    // âœ… Simple pattern: "name@123"
    const plainPassword = `${employee.name.split(" ")[0]}@123`; // "John@123"
    data.password = await bcrypt.hash(plainPassword, 10);
    employee.autoGeneratedPassword = plainPassword; // For frontend display
  }

  // In employeeService.js createEmployee
  data.zone = Array.isArray(data.zone) ? data.zone : [data.zone];
  data.ward = Array.isArray(data.ward) ? data.ward : [data.ward];

  Object.assign(employee, data);
  await employee.save();
  return employee;
};

export const getEmployees = async (
  searchCondition = {},
  page = 1,
  limit = 9
) => {
  const skip = (page - 1) * limit;

  const totalItems = await Employee.countDocuments(searchCondition);

  const employees = await Employee.find(searchCondition)
    .sort({ })
    .skip(skip)
    .limit(limit);

  return {
    data: employees,
    pagination: {
      totalItems,
      currentPage: page,
      totalPages: Math.ceil(totalItems / limit),
    },
  };
};

export const deleteEmployee = async (id, sessionId) => {
  

  const employee = await Employee.findById(id);
  if (!employee) throw new Error("Employee not found");

  await Employee.findByIdAndDelete(id);

  return { message: "Employee deleted successfully" };
};


export const generateEmployeeWiseReport = async (fromDate, toDate) => {
  try {
    const from = new Date(fromDate);
    from.setHours(0, 0, 0, 0);
    const to = new Date(toDate);
    to.setHours(23, 59, 59, 999);

    console.log('ðŸ“… Report date range:', { from, to });

    // Get all active employees
    const employees = await Employee.find({ status: "Active" }).lean();
    console.log('ðŸ‘¥ Active employees found:', employees.length);

    // Get bin events aggregated by zone/ward
    const binEvents = await binfulleventSchema.aggregate([
      { $match: { date: { $gte: from, $lte: to } } },
      {
        $group: {
          _id: { zone: "$zone", ward: "$ward" },
          totalTasks: { $sum: "$analytics.fullEvents" },
          completedTasks: { $sum: "$analytics.clearedEvents" },
          totalGarbage: { $sum: "$analytics.totalTonnageCleared" },
          totalClearTime: { $sum: "$analytics.totalClearTimeMins" },
          escalations: {
            $sum: {
              $cond: [
                { $gt: ["$analytics.consecutiveDaysFull", 1] },
                1,
                0
              ]
            }
          }
        }
      }
    ]);

    console.log('ðŸ—‘ï¸ Bin events found:', binEvents.length);

    // Map employees to their zone/ward data
    const reportData = employees.map(employee => {
      let taskAssigned = 0;
      let taskCompleted = 0;
      let totalGarbage = 0;
      let totalClearTime = 0;
      let escalations = 0;

      // Get employee zones/wards - handle both formats
      const employeeZones = employee.zone || [];
      const employeeWards = employee.ward || [];
      const assignedZones = employee.assignedZones || [];

      // Method 1: Match using zone/ward arrays
      employeeZones.forEach((zone, index) => {
        const ward = employeeWards[index];
        const event = binEvents.find(
          e => e._id.zone === zone && e._id.ward === ward
        );

        if (event) {
          taskAssigned += event.totalTasks || 0;
          taskCompleted += event.completedTasks || 0;
          totalGarbage += event.totalGarbage || 0;
          totalClearTime += event.totalClearTime || 0;
          escalations += event.escalations || 0;
        }
      });

      // Method 2: Match using assignedZones array (if used)
      assignedZones.forEach(area => {
        const event = binEvents.find(
          e => e._id.zone === area.zone && e._id.ward === area.ward
        );

        if (event) {
          taskAssigned += event.totalTasks || 0;
          taskCompleted += event.completedTasks || 0;
          totalGarbage += event.totalGarbage || 0;
          totalClearTime += event.totalClearTime || 0;
          escalations += event.escalations || 0;
        }
      });

      // Format assigned zone/ward display
      let assignedZoneDisplay = "N/A";
      if (employeeZones.length > 0 && employeeWards.length > 0) {
        assignedZoneDisplay = employeeZones
          .map((zone, i) => `${zone}/${employeeWards[i] || ''}`)
          .filter(Boolean)
          .join(", ");
      } else if (assignedZones.length > 0) {
        assignedZoneDisplay = assignedZones
          .map(a => `${a.zone}/${a.ward}`)
          .join(", ");
      }

      return {
        employeename: employee.name || "N/A",
        assignedzone: assignedZoneDisplay,
        taskassigned: taskAssigned,
        taskcompleted: taskCompleted,
        escalations: escalations,
        garbage: `${parseFloat(totalGarbage.toFixed(2))} T`
      };
    });

    console.log('âœ… Report generated for', reportData.length, 'employees');
    return reportData;

  } catch (error) {
    console.error('âŒ Error generating employee report:', error);
    throw error;
  }
};

// Backend: updateemployee function
export const updateuser = async (id, data) => {
  const employee = await Employee.findById(id);
  if (!employee) throw new Error("Employee not found");

  // âœ… Phone/Email checks (your code)
  if (data.phonenumber && data.phonenumber !== employee.phonenumber) {
    const phoneExists = await Employee.findOne({
      phonenumber: data.phonenumber, _id: { $ne: id }
    });
    if (phoneExists) throw new Error("Phone number already exists!");
  }

  // âœ… AUTO: role_name â†’ role_id lookup
  if (data.role_name && data.role_name !== employee.role_name) {
    const role = await RoleModel.findOne({ role_name: data.role_name });
    if (!role) throw new Error(`Role "${data.role_name}" not found!`);
    
    data.role_id = role.role_id; // âœ… AUTO UPDATE role_id
    console.log(`ðŸ”„ Role changed: ${employee.role_name} â†’ ${data.role_name} (ID: ${data.role_id})`);
  }

  Object.assign(employee, data);
  await employee.save();
  return employee;
};



// âœ… SEPARATE Password change
export const changePassword = async (id, newPassword) => {
  const employee = await Employee.findById(id);
  if (!employee) throw new Error("Employee not found");

  const hashedPassword = await bcrypt.hash(newPassword, 10);
  employee.password = hashedPassword;
  await employee.save();

  return { success: true, message: "Password updated successfully" };
};
