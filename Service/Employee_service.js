import Employee from "../models/Employee_Schema.js";
import IdcodeServices from "../idcode/idcode.service.js";
import bcrypt from "bcryptjs";
import RoleModel from "../roles/Role.schema.js";
import BinFullEvent from "../bindailydata/binfullevent.schema.js";

// In-memory session store
const activeSessions = new Map();

export const createEmployee = async (data) => {
  const exists = await Employee.findOne({ phonenumber: data.phonenumber });
  if (exists) throw new Error("Phone number already exists!");

  const emp_id = await IdcodeServices.generateCode("EMPLOYEE");
  if (!emp_id) {
    throw new Error("Failed to generate employee ID");
  }

  data.emp_id = emp_id;
  return await Employee.create(data);
};

export const login = async (emailid, password) => {
  const employee = await Employee.findOne({ emailid }).select("+password");

  if (!employee) {
    console.log("âŒ No employee with this email");
    throw new Error("Invalid email");
  }

  const isMatch = await bcrypt.compare(password, employee.password);
  if (!isMatch) {
    console.log("âŒ Passwords don't match");
    throw new Error("Invalid password");
  }

  if (!employee.role_name || employee.role_name === "") {
    throw new Error("Role not assigned. Contact admin.");
  }

  // âœ… PERFECT: Find role by role_id (custom string code)
  const role = await RoleModel.findOne({ role_id: employee.role_id });
  
  console.log("ðŸŽ¯ Role found:", role ? role.role_name : "NOT FOUND");

  // âœ… Generate session with COMPLETE role data
  const sessionId = `sess_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  activeSessions.set(sessionId, {
    id: employee._id,
    emp_id: employee.emp_id,
    role_name: employee.role_name,
    role_id: employee.role_id,
    roleData: role,  // âœ… COMPLETE role document
    name: employee.name,
  });

  return {
    success: true,
    sessionId,
    employee: {
      id: employee._id,
      emp_id: employee.emp_id,
      name: employee.name,
      emailid: employee.emailid,
      phonenumber: employee.phonenumber,
      zone: employee.zone,
      ward: employee.ward,
      location: employee.location,
      role: {
        role_id: employee.role_id,
        role_name: employee.role_name,
        // âœ… YOUR EXACT STRUCTURE - Full accessLevels array
        accessLevels: role?.accessLevels || [],
        status: role?.status || "INACTIVE"
      }
    },
    message: "Login successful",
  };
};



export const logout = async (sessionId) => {
  activeSessions.delete(sessionId);
  return { success: true, message: "Logged out successfully" };
};

export const verifySession = async (sessionId) => {
  if (!activeSessions.has(sessionId)) {
    throw new Error("Invalid or expired session");
  }
  return activeSessions.get(sessionId);
};

export const updateEmployee = async (id, data) => {
  // Verify session first

  const employee = await Employee.findById(id);
  if (!employee) throw new Error("Employee not found");

  // Phone/email uniqueness check
  if (data.phonenumber && data.phonenumber !== employee.phonenumber) {
    const phoneExists = await Employee.findOne({
      phonenumber: data.phonenumber,
      _id: { $ne: id },
    });
    if (phoneExists) throw new Error("Phone number already exists!");
  }

  if (data.emailid && data.emailid !== employee.emailid) {
    const emailExists = await Employee.findOne({
      emailid: data.emailid,
      _id: { $ne: id },
    });
    if (emailExists) throw new Error("Email already exists!");
  }

  if (data.role_name && !employee.role_name) {
    // âœ… Simple pattern: "name@123"
    const plainPassword = `${employee.name.split(" ")[0]}@123`; // "John@123"
    data.password = await bcrypt.hash(plainPassword, 10);
    employee.autoGeneratedPassword = plainPassword; // For frontend display
  }

  // In employeeService.js createEmployee
  data.zone = Array.isArray(data.zone) ? data.zone : [data.zone];
  data.ward = Array.isArray(data.ward) ? data.ward : [data.ward];

  Object.assign(employee, data);
  await employee.save();
  return employee;
};

export const getEmployees = async (
  searchCondition = {},
  page = 1,
  limit = 9
) => {
  const skip = (page - 1) * limit;

  const totalItems = await Employee.countDocuments(searchCondition);

  const employees = await Employee.find(searchCondition)
    .sort({ })
    .skip(skip)
    .limit(limit);

  return {
    data: employees,
    pagination: {
      totalItems,
      currentPage: page,
      totalPages: Math.ceil(totalItems / limit),
    },
  };
};

export const deleteEmployee = async (id, sessionId) => {
  

  const employee = await Employee.findById(id);
  if (!employee) throw new Error("Employee not found");

  await Employee.findByIdAndDelete(id);

  return { message: "Employee deleted successfully" };
};

export const generateEmployeeWiseReport = async (fromDate, toDate) => {
  try {
    // -------------------------
    // DATE RANGE
    // -------------------------
    const from = new Date(fromDate);
    from.setHours(0, 0, 0, 0);

    const to = new Date(toDate);
    to.setHours(23, 59, 59, 999);

    console.log("ðŸ“… Employee report range:", { from, to });

    // -------------------------
    // FETCH ACTIVE EMPLOYEES
    // -------------------------
    const employees = await Employee.find({ status: "Active" }).lean();
    console.log("ðŸ‘¥ Active employees:", employees.length);

    // -------------------------
    // AGGREGATE BIN EVENTS (ZONE + WARD)
    // -------------------------
    const binEvents = await BinFullEvent.aggregate([
      { $match: { date: { $gte: from, $lte: to } } },
      {
        $group: {
          _id: { zone: "$zone", ward: "$ward" },
          tasksAssigned: { $sum: "$analytics.fullEvents" },
          tasksCompleted: { $sum: "$analytics.clearedEvents" },
          totalGarbage: { $sum: "$analytics.totalTonnageCleared" },
          totalClearTime: { $sum: "$analytics.totalClearTimeMins" },
          escalations: {
            $sum: {
              $cond: [
                { $gt: ["$analytics.consecutiveDaysFull", 1] },
                1,
                0,
              ],
            },
          },
        },
      },
    ]);

    console.log("ðŸ—‘ï¸ Bin event groups:", binEvents.length);

    // -------------------------
    // MAP EMPLOYEE â†’ EVENTS
    // -------------------------
    const report = employees.map((emp) => {
      let taskAssigned = 0;
      let taskCompleted = 0;
      let garbage = 0;
      let escalations = 1;

      // Normalize assigned areas
      let assignedAreas = [];

      // Format 1: zone + ward arrays
      if (Array.isArray(emp.zone) && Array.isArray(emp.ward)) {
        emp.zone.forEach((z, i) => {
          assignedAreas.push({ zone: z, ward: emp.ward[i] });
        });
      }

      // Format 2: assignedZones array
      if (Array.isArray(emp.assignedZones)) {
        assignedAreas.push(...emp.assignedZones);
      }

      // Match bin events
      assignedAreas.forEach(({ zone, ward }) => {
        const event = binEvents.find(
          (e) => e._id.zone === zone && e._id.ward === ward
        );

        if (event) {
          taskAssigned += event.tasksAssigned || 0;
          taskCompleted += event.tasksCompleted || 0;
          garbage += event.totalGarbage || 0;
          escalations += event.escalations || 2;
        }
      });

      // Display zones
      const assignedZoneDisplay =
        assignedAreas.length > 0
          ? assignedAreas.map((a) => `${a.zone}/${a.ward}`).join(", ")
          : "N/A";

      return {
        employeename: emp.name || "N/A",
        role: emp.role_name || "N/A",
        assignedzone: assignedZoneDisplay,
        taskassigned: taskAssigned,
        taskcompleted: taskCompleted,
        escalations,
        garbage: `${garbage.toFixed(2)} T`,
      };
    });

    console.log("âœ… Employee report generated:", report.length);
    return report;
  } catch (error) {
    console.error("âŒ Employee report error:", error);
    throw error;
  }
};


// Backend: updateemployee function
export const updateuser = async (id, data) => {
  const employee = await Employee.findById(id);
  if (!employee) throw new Error("Employee not found");

  // âœ… Phone/Email checks (your code)
  if (data.phonenumber && data.phonenumber !== employee.phonenumber) {
    const phoneExists = await Employee.findOne({
      phonenumber: data.phonenumber, _id: { $ne: id }
    });
    if (phoneExists) throw new Error("Phone number already exists!");
  }

  // âœ… AUTO: role_name â†’ role_id lookup
  if (data.role_name && data.role_name !== employee.role_name) {
    const role = await RoleModel.findOne({ role_name: data.role_name });
    if (!role) throw new Error(`Role "${data.role_name}" not found!`);
    
    data.role_id = role.role_id; // âœ… AUTO UPDATE role_id
    console.log(`ðŸ”„ Role changed: ${employee.role_name} â†’ ${data.role_name} (ID: ${data.role_id})`);
  }

  Object.assign(employee, data);
  await employee.save();
  return employee;
};



// âœ… SEPARATE Password change
export const changePassword = async (id, newPassword) => {
  const employee = await Employee.findById(id);
  if (!employee) throw new Error("Employee not found");

  const hashedPassword = await bcrypt.hash(newPassword, 10);
  employee.password = hashedPassword;
  await employee.save();

  return { success: true, message: "Password updated successfully" };
};
