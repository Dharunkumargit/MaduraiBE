import Employee from "../models/Employee_Schema.js";
import IdcodeServices from "../idcode/idcode.service.js";
import bcrypt from "bcryptjs";
import RoleModel from "../roles/Role.schema.js";

// In-memory session store
const activeSessions = new Map();

export const createEmployee = async (data) => {
  const exists = await Employee.findOne({ phonenumber: data.phonenumber });
  if (exists) throw new Error("Phone number already exists!");

  const emp_id = await IdcodeServices.generateCode("EMPLOYEE");
  if (!emp_id) {
    throw new Error("Failed to generate employee ID");
  }

  data.emp_id = emp_id;
  return await Employee.create(data);
};

export const login = async (emailid, password) => {
  const employee = await Employee.findOne({ emailid }).select("+password");

  if (!employee) {
    console.log("âŒ No employee with this email");
    throw new Error("Invalid email");
  }

  const isMatch = await bcrypt.compare(password, employee.password);
  if (!isMatch) {
    console.log("âŒ Passwords don't match");
    throw new Error("Invalid password");
  }

  if (!employee.role_name || employee.role_name === "") {
    throw new Error("Role not assigned. Contact admin.");
  }

  // âœ… PERFECT: Find role by role_id (custom string code)
  const role = await RoleModel.findOne({ role_id: employee.role_id });
  
  console.log("ðŸŽ¯ Role found:", role ? role.role_name : "NOT FOUND");

  // âœ… Generate session with COMPLETE role data
  const sessionId = `sess_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  activeSessions.set(sessionId, {
    id: employee._id,
    emp_id: employee.emp_id,
    role_name: employee.role_name,
    role_id: employee.role_id,
    roleData: role,  // âœ… COMPLETE role document
    name: employee.name,
  });

  return {
    success: true,
    sessionId,
    employee: {
      id: employee._id,
      emp_id: employee.emp_id,
      name: employee.name,
      emailid: employee.emailid,
      phonenumber: employee.phonenumber,
      zone: employee.zone,
      ward: employee.ward,
      location: employee.location,
      role: {
        role_id: employee.role_id,
        role_name: employee.role_name,
        // âœ… YOUR EXACT STRUCTURE - Full accessLevels array
        accessLevels: role?.accessLevels || [],
        status: role?.status || "INACTIVE"
      }
    },
    message: "Login successful",
  };
};



export const logout = async (sessionId) => {
  activeSessions.delete(sessionId);
  return { success: true, message: "Logged out successfully" };
};

export const verifySession = async (sessionId) => {
  if (!activeSessions.has(sessionId)) {
    throw new Error("Invalid or expired session");
  }
  return activeSessions.get(sessionId);
};

export const updateEmployee = async (id, data) => {
  // Verify session first

  const employee = await Employee.findById(id);
  if (!employee) throw new Error("Employee not found");

  // Phone/email uniqueness check
  if (data.phonenumber && data.phonenumber !== employee.phonenumber) {
    const phoneExists = await Employee.findOne({
      phonenumber: data.phonenumber,
      _id: { $ne: id },
    });
    if (phoneExists) throw new Error("Phone number already exists!");
  }

  if (data.emailid && data.emailid !== employee.emailid) {
    const emailExists = await Employee.findOne({
      emailid: data.emailid,
      _id: { $ne: id },
    });
    if (emailExists) throw new Error("Email already exists!");
  }

  if (data.role_name && !employee.role_name) {
    // âœ… Simple pattern: "name@123"
    const plainPassword = `${employee.name.split(" ")[0]}@123`; // "John@123"
    data.password = await bcrypt.hash(plainPassword, 10);
    employee.autoGeneratedPassword = plainPassword; // For frontend display
  }

  // In employeeService.js createEmployee
  data.zone = Array.isArray(data.zone) ? data.zone : [data.zone];
  data.ward = Array.isArray(data.ward) ? data.ward : [data.ward];

  Object.assign(employee, data);
  await employee.save();
  return employee;
};

export const getEmployees = async (
  searchCondition = {},
  page = 1,
  limit = 9
) => {
  const skip = (page - 1) * limit;

  const totalItems = await Employee.countDocuments(searchCondition);

  const employees = await Employee.find(searchCondition)
    .sort({ })
    .skip(skip)
    .limit(limit);

  return {
    data: employees,
    pagination: {
      totalItems,
      currentPage: page,
      totalPages: Math.ceil(totalItems / limit),
    },
  };
};

export const deleteEmployee = async (id, sessionId) => {
  

  const employee = await Employee.findById(id);
  if (!employee) throw new Error("Employee not found");

  await Employee.findByIdAndDelete(id);

  return { message: "Employee deleted successfully" };
};

export const generateEmployeeWiseReport = async (
  fromDate,
  toDate,
  sessionId,
) => {
  const filter = {};
  if (fromDate && toDate) {
    filter.createdAt = {
      $gte: new Date(fromDate),
      $lte: new Date(toDate),
    };
  }

  const employees = await Employee.find(filter);
  return employees.map((emp) => {
    const taskassigned = Math.floor(Math.random() * 20) + 5;
    const taskcompleted = Math.floor(taskassigned * 0.8);
    const averagecleaningtime = Math.floor(Math.random() * 30) + 15;
    const escalations = Math.floor(Math.random() * 5);
    const garbage = Math.floor(Math.random() * 10) + 1;
    const compliance = Math.round((taskcompleted / taskassigned) * 100);

    return {
      employeename: emp.name,
      assignedzone: emp.zone?.[0] || emp.ward?.[0] || "N/A",
      taskassigned,
      taskcompleted,
      averagecleaningtime: `${averagecleaningtime} mins`,
      compliance: `${compliance}%`,
      escalations,
      garbage: `${garbage} Tons`,
    };
  });
};

// Backend: updateemployee function
export const updateuser = async (id, data) => {
  const employee = await Employee.findById(id);
  if (!employee) throw new Error("Employee not found");

  // âœ… Phone/Email checks (your code)
  if (data.phonenumber && data.phonenumber !== employee.phonenumber) {
    const phoneExists = await Employee.findOne({
      phonenumber: data.phonenumber, _id: { $ne: id }
    });
    if (phoneExists) throw new Error("Phone number already exists!");
  }

  // âœ… AUTO: role_name â†’ role_id lookup
  if (data.role_name && data.role_name !== employee.role_name) {
    const role = await RoleModel.findOne({ role_name: data.role_name });
    if (!role) throw new Error(`Role "${data.role_name}" not found!`);
    
    data.role_id = role.role_id; // âœ… AUTO UPDATE role_id
    console.log(`ðŸ”„ Role changed: ${employee.role_name} â†’ ${data.role_name} (ID: ${data.role_id})`);
  }

  Object.assign(employee, data);
  await employee.save();
  return employee;
};



// âœ… SEPARATE Password change
export const changePassword = async (id, newPassword) => {
  const employee = await Employee.findById(id);
  if (!employee) throw new Error("Employee not found");

  const hashedPassword = await bcrypt.hash(newPassword, 10);
  employee.password = hashedPassword;
  await employee.save();

  return { success: true, message: "Password updated successfully" };
};
